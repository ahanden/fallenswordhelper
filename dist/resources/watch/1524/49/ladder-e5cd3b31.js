import { i as interceptSubmit } from './interceptSubmit-9bdd8d86.js';
import { n as noop, e as element, s as space, a as attr, i as insert, b as append, h as handle_promise, u as update_await_block_branch, d as detach, c as empty, l as listen, r as run_all, S as SvelteComponent, f as init, g as safe_not_equal } from './index-eac398e5.js';
import { a7 as isBoolean, T as sendEvent, x as callApp, q as extend, a8 as isUndefined, u as indexAjaxData, t as createDocument, $ as $dataAccess, I as getValue, E as querySelector, P as isArray, a9 as now, aa as defLastLadderReset, A as setText, B as setInnerHtml } from './calfSystem-579856fa.js';
import { o as outputFormat } from './outputFormat-3f519c21.js';
import './formToUrl-72736914.js';

var css = "td.svelte-1quw1g.svelte-1quw1g:nth-child(1){height:25px}td.svelte-1quw1g:nth-child(1) span.svelte-1quw1g{cursor:pointer;text-decoration:underline}td.svelte-1quw1g.svelte-1quw1g:nth-child(2){text-align:right}td.svelte-1quw1g:nth-child(2) div.svelte-1quw1g{float:right;height:12px;position:relative;width:12px}";
var modules_acd3a5b7 = {};

/* src\modules\ladder\OptIn.svelte generated by Svelte v3.38.3 */

function create_catch_block_1(ctx) {
	return { c: noop, m: noop, p: noop, d: noop };
}

// (40:27)    {#if isBoolean(opt)}
function create_then_block(ctx) {
	let show_if = isBoolean(/*opt*/ ctx[0]);
	let if_block_anchor;
	let if_block = show_if && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*opt*/ 1) show_if = isBoolean(/*opt*/ ctx[0]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (41:2) {#if isBoolean(opt)}
function create_if_block(ctx) {
	let tr;
	let td0;
	let t1;
	let td1;
	let promise;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block_1,
		then: create_then_block_1,
		catch: create_catch_block
	};

	handle_promise(promise = /*togglePromise*/ ctx[1], info);

	return {
		c() {
			tr = element("tr");
			td0 = element("td");
			td0.innerHTML = `<span data-tooltip="Ticking this box opts you in to the PVP Ladder, unticking it will remove you from the PVP Ladder." class="svelte-1quw1g">PvP Ladder Opt-in:</span>`;
			t1 = space();
			td1 = element("td");
			info.block.c();
			attr(td0, "class", "svelte-1quw1g");
			attr(td1, "class", "svelte-1quw1g");
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td0);
			append(tr, t1);
			append(tr, td1);
			info.block.m(td1, info.anchor = null);
			info.mount = () => td1;
			info.anchor = null;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*togglePromise*/ 2 && promise !== (promise = /*togglePromise*/ ctx[1]) && handle_promise(promise, info)) {
				
			} else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		d(detaching) {
			if (detaching) detach(tr);
			info.block.d();
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script>   import isBoolean from '../common/isBoolean';   import sendEvent from '../analytics/sendEvent';    export let isOnLadder;   export let toggleLadder;    let opt;    async function init() {     opt = await isOnLadder();   }
function create_catch_block(ctx) {
	return { c: noop, m: noop, p: noop, d: noop };
}

// (51:8) {:then}
function create_then_block_1(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "checkbox");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			input.checked = /*opt*/ ctx[0];

			if (!mounted) {
				dispose = [
					listen(input, "change", /*input_change_handler*/ ctx[6]),
					listen(input, "click", /*toggle*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*opt*/ 1) {
				input.checked = /*opt*/ ctx[0];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (47:30)            <div>             <span class="fshSpinner fshSpinner12"></span>           </div>         {:then}
function create_pending_block_1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<span class="fshSpinner fshSpinner12 svelte-1quw1g"></span>`;
			attr(div, "class", "svelte-1quw1g");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (1:0) <script>   import isBoolean from '../common/isBoolean';   import sendEvent from '../analytics/sendEvent';    export let isOnLadder;   export let toggleLadder;    let opt;    async function init() {     opt = await isOnLadder();   }
function create_pending_block(ctx) {
	return { c: noop, m: noop, p: noop, d: noop };
}

function create_fragment(ctx) {
	let await_block_anchor;
	let promise;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block_1,
		value: 7
	};

	handle_promise(promise = /*init*/ ctx[2](), info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { isOnLadder } = $$props;
	let { toggleLadder } = $$props;
	let opt;

	async function init() {
		$$invalidate(0, opt = await isOnLadder());
	}

	let togglePromise;

	function toggle() {
		$$invalidate(0, opt = !opt);
		$$invalidate(1, togglePromise = toggleLadder(opt));
		sendEvent("ladder", "opt in/out");
	}

	function input_change_handler() {
		opt = this.checked;
		$$invalidate(0, opt);
	}

	$$self.$$set = $$props => {
		if ("isOnLadder" in $$props) $$invalidate(4, isOnLadder = $$props.isOnLadder);
		if ("toggleLadder" in $$props) $$invalidate(5, toggleLadder = $$props.toggleLadder);
	};

	return [
		opt,
		togglePromise,
		init,
		toggle,
		isOnLadder,
		toggleLadder,
		input_change_handler
	];
}

class OptIn extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { isOnLadder: 4, toggleLadder: 5 });
	}
}

function settings(data) {
  return callApp(extend({ cmd: 'settings' }, data));
}

function flags(flagsArray) {
  return settings({
    subcmd: 'flags',
    flags: flagsArray.map((i) => (i ? 1 : 0)),
  });
}

const uiFlags = [
  'ui_preference_11',
  'ui_preference_15',
  'disable_wordcensor',
  'ui_preference_30',
  'ui_preference_21',
  'ui_preference_33',
  'ui_preference_23',
];

function hasError(response) {
  if (isUndefined(response)) {
    return {
      s: false,
      r: { e: 'Could not connect to FS servers' },
    };
  }
  return false;
}

async function updateSettings(prm, f) {
  const last = await prm;
  if (!isUndefined(last) && last !== false) { return last; }
  const response = await indexAjaxData(f);
  return hasError(response);
}

async function getSettings() {
  const settingsHTML = await indexAjaxData({ cmd: 'settings' });
  const check = hasError(settingsHTML);
  if (check) { return check; }
  return settingsHTML;
}

function updateLadder(form, opt) {
  const data = new FormData(form);
  data.append('pvp_ladder', opt);
  return Object.fromEntries(data.entries());
}

function updateUI(form, flags) {
  const ui = new FormData(form);
  uiFlags.forEach((f, i) => ui.set(f, flags[i + 1]));
  return Object.fromEntries(ui.entries());
}

async function settingsFlags(flags) {
  const settingsHTML = await getSettings();
  const check = hasError(settingsHTML);
  if (check) { return check; }
  const settingsPage = createDocument(settingsHTML);

  const ladder = updateLadder(settingsPage.forms[0], flags[0]);
  const ui = updateUI(settingsPage.forms[2], flags);

  const result = await [ladder, ui].reduce(updateSettings, Promise.resolve());
  if (result === false) {
    return { s: true };
  }
  return result;
}

function daSettingsFlags(flagsArray) {
  return $dataAccess(flags, settingsFlags, flagsArray);
}

const skillMap = [
  { name: 'ca_default', id: 54 },
  { name: 'sc_default', id: 101 },
  { name: 'nv_default', id: 60 },
  { name: 'barricade_default', id: 98 },
];

function getSkills(form) {
  const skills = form.getAll('blockedSkillList[]')
    .map((e) => ({
      id: parseInt(e, 10),
      blocked: true,
      level: 0,
    }));

  skillMap.forEach((skill) => {
    const index = skills.findIndex((s) => s.id === skills.id);
    if (index === -1) {
      skills.push({
        id: parseInt(skill.id, 10),
        blocked: false,
        level: form.get(skill.name),
      });
    } else {
      skills[index].level = form.get(skill.name);
    }
  });
  return skills;
}

function getDrops(form) {
  const entries = [...form.entries()];
  return entries.filter((e) => e[0].startsWith('discardPref'))
    .map((e) => ({
      id: parseInt(e[0][e[0].length - 1], 10),
      action: parseInt(e[1], 10),
    }));
}

function makeFlags(fds) {
  return [
    fds[0].get('pvp_ladder') === '1',
    fds[2].get('ui_preference_11') === '1',
    fds[2].get('ui_preference_15') === '1',
    fds[2].get('disable_wordcensor') === '1',
    fds[2].get('ui_preference_30') === '1',
    fds[2].get('ui_preference_21') === '1',
    fds[2].get('ui_preference_33') === '1',
    fds[2].get('ui_preference_23') === '1',
  ];
}

function resultObject(fds) {
  return {
    s: true,
    r: {
      skills: getSkills(fds[4]),
      item_drop_rarity: getDrops(fds[1]),
      flags: makeFlags(fds),
      min_group_join_level: parseInt(fds[0].get('min_group_level'), 10),
      item_drop_discard_level: parseInt(fds[1].get('auto_discard_level'), 10),
      player_block_type: parseInt(fds[2].get('block_level'), 10),
    },
  };
}

async function settingsView() {
  const settingsHTML = await indexAjaxData({ cmd: 'settings' });
  if (!settingsHTML) {
    return {
      s: false,
      e: { message: 'Could not connect to FS servers', code: 1 },
    };
  }
  const settingsPage = createDocument(settingsHTML);
  const fds = [...settingsPage.forms].map((e) => new FormData(e));
  return resultObject(fds);
}

function view() {
  return settings({ subcmd: 'view' });
}

function daSettingsView() {
  return $dataAccess(view, settingsView);
}

let myFlags;

async function isOnLadder() {
  const response = await daSettingsView();
  myFlags = response.r?.flags;
  return myFlags?.[0];
}

async function toggleLadder(o) {
  if (isArray(myFlags)) {
    myFlags[0] = o;
    return daSettingsFlags(myFlags);
  }
}

function startApp(target) {
  return new OptIn({
    props: { toggleLadder, isOnLadder },
    target,
  });
}

function optInWidget() {
  if (getValue('optInOnLadderPage')) {
    const target = querySelector('#pCC table tbody');
    startApp(target);
  }
}

function formatLastReset(lastLadderReset) {
  let m = Math.floor((now - lastLadderReset) / 60000);
  const h = Math.floor(m / 60);
  m %= 60;
  return `${outputFormat(h, ' hours, ') + m} mins`;
}

function formatTime() {
  const lastLadderReset = getValue(defLastLadderReset);
  if (lastLadderReset < now - 48 * 60 * 60 * 1000) {
    return '<span class="fshLink tip-static" data-tipped="FSH has not seen '
      + 'the last ladder reset.<br>You can find it in your log if you '
      + 'qualified<br>or Tavern Rumours.">???</span>';
  }
  return formatLastReset(lastLadderReset);
}

function makeLeftCell(newRow) {
  const leftCell = newRow.insertCell(-1);
  leftCell.height = 25;
  setText('Last Reset:', leftCell);
}

function makeRightCell(newRow) {
  const rightCell = newRow.insertCell(-1);
  rightCell.align = 'right';
  setInnerHtml(formatTime(), rightCell);
}

function lastReset() {
  const firstTable = querySelector('#pCC table');
  if (!firstTable) { return; }
  const newRow = firstTable.insertRow(-1);
  makeLeftCell(newRow);
  makeRightCell(newRow);
}

function trackLastReset() {
  if (getValue('trackLadderReset')) {
    lastReset();
  }
}

function ladder() {
  interceptSubmit();
  trackLastReset();
  optInWidget();
}

export default ladder;
//# sourceMappingURL=ladder-e5cd3b31.js.map
